/**
 * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 * Universidad de los Andes (Bogotá - Colombia)
 * Departamento de Ingeniería de Sistemas y Computación 
 * Licenciado bajo el esquema Academic Free License version 2.1 
 *
 * Proyecto Cupi2 (http://cupi2.uniandes.edu.co)
 * Ejercicio: n12_batallaPokemon
 * Autor: Equipo Cupi2 2016
 * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 */

package uniandes.cupi2.batallaPokemon.servidor.mundo;

import java.io.*;
import java.net.*;
import java.sql.*;
import java.util.*;

import javax.swing.JOptionPane;

import uniandes.cupi2.batallaPokemon.cliente.mundo.BatallaPokemonException;

/**
 * Servidor BatallaPokemon se encarga de recibir conexiones de los clientes y organizar las batallas. <br>
 * <b>inv:</b><br>
 * receptor!= null <br>
 * config!=null <br>
 * adminResultados!=null <br>
 * encuentros!=null <br>
 */
public class BatallaPokemon
{
    // -----------------------------------------------------------------
    // Constantes
    // -----------------------------------------------------------------

    /**
     * Mensaje de registro de un jugador
     */
    public static final String REGISTRO = "REGISTRO";

    /**
     * Mensaje de login de un jugador
     */
    public static final String LOGIN = "LOGIN";

    // -----------------------------------------------------------------
    // Atributos
    // -----------------------------------------------------------------

    /**
     * Punto por el cual los clientes solicitan conexiones.
     */
    private ServerSocket receptor;

    /**
     * Propiedades que contienen la configuración de la aplicación.
     */
    private Properties config;

    /**
     * Administrador que permite registrar los resultados sobre la base de datos.
     */
    private AdministradorResultados adminResultados;

    /**
     * Este es el canal utilizado para establecer una comunicación con un jugador que está en espera de un oponente. <br>
     * Si no hay jugadores en espera, este canal debe ser null.
     */
    private Socket socketJugadorEnEspera;

    /**
     * Registro del jugador que está en espera de un oponente.
     */
    private RegistroJugador registroJugadorEnEspera;

    /**
     * Es una colección con los encuentros que se están llevando a cabo en este momento.
     */
    protected Collection encuentros;

    // -----------------------------------------------------------------
    // Constructores
    // -----------------------------------------------------------------

    /**
     * Inicia el servidor y deja listo el administrador de resultados.
     * @param pArchivo Archivo de propiedades que tiene la configuración del servidor. pArchivo != null.
     * @throws Exception Se lanza esta excepción si hay problemas con el archivo de propiedades o hay problemas en la conexión a la base de datos.
     * @throws SQLException Se lanza esta excepción si hay problemas conectando el almacén a la base de datos.
     */
    public BatallaPokemon( String pArchivo ) throws SQLException, Exception
    {
        encuentros = new Vector( );

        cargarConfiguracion( pArchivo );

        adminResultados = new AdministradorResultados( config );
        adminResultados.conectarABD( );
        adminResultados.inicializarTabla( );
        verificarInvariante( );
    }

    // -----------------------------------------------------------------
    // Métodos
    // -----------------------------------------------------------------

    /**
     * Retorna al administrador de resultados.
     * @return Administrador de resultados.
     */
    public AdministradorResultados darAdministradorResultados( )
    {
        return adminResultados;
    }

    /**
     * Retorna una colección actualizada con las batallas que se están desarrollando actualmente y no han terminado.<br>
     * Si había batallas en la lista que ya habían terminado deben ser eliminados.
     * @return Colección de batallas.
     */
    public Collection darListaActualizadaBatallas( )
    {
        Collection listaActualizada = new Vector( );

        // Armar la lista actualizada con las batallas que no han terminado.
        Iterator iter = encuentros.iterator( );
        while( iter.hasNext( ) )
        {
            Batalla e = ( Batalla )iter.next( );
            if( !e.encuentroTerminado( ) )
                listaActualizada.add( e );
        }

        // Reemplazar la lista antigua con la lista actualizada.
        encuentros = listaActualizada;

        return encuentros;
    }

    /**
     * Carga la configuración a partir de un archivo de propiedades.
     * @param pArchivo Archivo de propiedades que contiene la configuración que requiere el servidor. pArchivo != null y el archivo debe contener la propiedad
     *        "servidor.puerto" y las propiedades que requiere el administrador de resultados.
     * @throws Exception Se lanza esta excepción si hay problemas cargando el archivo de propiedades.
     */
    private void cargarConfiguracion( String pArchivo ) throws Exception
    {
        FileInputStream fis = new FileInputStream( pArchivo );
        config = new Properties( );
        config.load( fis );
        fis.close( );
    }

    /**
     * Recibe todas las conexiones entrantes y crear las batallas cuando fuera necesario.
     */
    public void recibirConexiones( ) 
    {
        String aux = config.getProperty( "servidor.puerto" );
        int puerto = Integer.parseInt( aux );
        try
        {
            receptor = new ServerSocket( puerto );

            while( true )
            {
                // Esperar una nueva conexión.
                Socket socketNuevoCliente = receptor.accept( );

                // Intentar iniciar un encuentro con el nuevo cliente.
                crearEncuentro( socketNuevoCliente );
            }
        }
        catch( IOException e )
        {
            e.printStackTrace( );
        }
        finally
        {
            try
            {
                receptor.close( );
            }
            catch( IOException e )
            {
                e.printStackTrace( );
            }
        }
    }

    /**
     * Intenta crear e iniciar un nueva batalla con el jugador que se acaba de conectar. <br>
     * Si no se tiene ya un oponente, entonces el jugador queda en espera de que otra persona se conecte.
     * @param pSocketNuevoCliente El canal que permite la comunicación con el nuevo cliente. pSocketNuevoCliente != null.
     * @throws IOException Se lanza esta excepción si se presentan problemas de comunicación.
     */
    synchronized private void crearEncuentro( Socket pSocketNuevoCliente ) 
    {

        PrintWriter out1;
        BufferedReader in1;
        RegistroJugador registroActual = null;
        
        try
        {
            
            out1 = new PrintWriter( pSocketNuevoCliente.getOutputStream( ), true );
            in1 = new BufferedReader( new InputStreamReader( pSocketNuevoCliente.getInputStream( ) ) );

            // Leer la información sobre los jugadores.
            String informacion = in1.readLine( );
            try
            {
            registroActual = consultarJugador( informacion );

            if( socketJugadorEnEspera == null )
            {
                // No hay un oponente aún, así que hay que dejarlo en espera.
                socketJugadorEnEspera = pSocketNuevoCliente;
                registroJugadorEnEspera = registroActual;
            }
            else
            {
                // Ya se tiene un oponente así que se puede empezar una partida.
       

                Batalla nuevo = new Batalla( socketJugadorEnEspera, pSocketNuevoCliente, in1, out1, adminResultados, registroJugadorEnEspera, registroActual );
                iniciarEncuentro( nuevo );
                socketJugadorEnEspera = null;

            }
            }catch(BatallaPokemonException e)
            {
                out1.println( Batalla.ERROR +":" + e.getMessage( ));
            }
        }
        catch( IOException e )
        {
            try
            {
                socketJugadorEnEspera.close( );
                pSocketNuevoCliente.close( );
            }
            catch( IOException e1 )
            {
                //Hubo un error cerrando el canal
            }
            
        }

        verificarInvariante( );
    }
    /**
     * Retorna el registro de un jugador a partir del mensaje que envió cuando entró al encuentro.
     * @param pInformacion Mensaje que fue enviado. pInformacion != null.
     * @return Retorna la información del jugador.
     * @throws BatallaNavalException Se lanza esta excepción si hay problemas consultando a la base de datos o si recibe un mensaje con un formato inesperado.
     */
    private RegistroJugador consultarJugador( String pInformacion ) throws BatallaPokemonException
    {
        RegistroJugador registro = null;
        if( pInformacion.startsWith( LOGIN ) )
        {
            String alias = pInformacion.split( ":" )[ 1 ];
            String password = pInformacion.split( ":" )[ 2 ];
            try
            {
                registro = adminResultados.consultarRegistroJugador( password, alias );

            }
            catch( SQLException e )
            {
                throw new BatallaPokemonException( "Login no exitoso: " + e.getMessage( ) + "." );
            }
        }
        else if( pInformacion.startsWith( REGISTRO ) )
        {
            String alias = pInformacion.split( ":" )[ 1 ];
            String nombre = pInformacion.split( ":" )[ 2 ];
            String apellidos = pInformacion.split( ":" )[ 3 ];
            String password = pInformacion.split( ":" )[ 4 ];
            try
            {
                registro = adminResultados.crearRegistroJugador( alias, nombre, apellidos, password );

            }
            catch( SQLException e )
            {
                throw new BatallaPokemonException( "Registro no exitoso: " + e.getMessage( ) + "." );
            }
        }
        else
        {
            throw new BatallaPokemonException( "El mensaje no tiene el formato esperado." );
        }
        return registro;
    }
    /**
     * Agrega la batalla a la lista de batallas en curso y lo inicia.
     * @param pNuevaBatalla Batalla que no ha sido inicializada ni agregada a la lista de batallas. pNuevaBatalla != null.
     */
    protected void iniciarEncuentro( Batalla pNuevaBatalla )
    {
        encuentros.add( pNuevaBatalla );
        pNuevaBatalla.start( );
    }

    // -----------------------------------------------------------------
    // Invariante
    // -----------------------------------------------------------------

    /**
     * Verifica el invariante de la clase <br>
     * <b>inv:</b><br>
     * receptor!= null <br>
     * config!=null <br>
     * adminResultados!=null <br>
     * encuentros!=null <br>
     */
    private void verificarInvariante( )
    {
        assert receptor != null : "Canal inválido.";
        assert config != null : "Conjunto de propiedades inválidas.";
        assert adminResultados != null : "El administrador de resultados no debería ser null.";
        assert encuentros != null : "La lista de encuentros no debería ser null.";
    }
    // -----------------------------------------------------------------
    // Puntos de Extensión
    // -----------------------------------------------------------------

    /**
     * Método para la extensión 1.
     * @return Respuesta 1.
     */
    public String metodo1( )
    {
        return "Respuesta 1";
    }

    /**
     * Método para la extensión2.
     * @return Respuesta 2.
     */
    public String metodo2( )
    {
        return "Respuesta 2";
    }

}
